variables:
  DOCKER_CONFIG: "$CI_PROJECT_DIR/.docker"


stages:
  - build
  - prepare
  - validate
  # - plan
  - apply
  - deploy
  # - provision
  - monitor
  - destroy

build-docker-image:
  stage: build
  image: docker:24.0.5
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "" # Vide pour l'instant pour établie la connection entre les conteneurs
  before_script:
    - mkdir -p $DOCKER_CONFIG  # Ensure the Docker config directory exists
    - echo "$PULL_PAT_TOKEN" | docker login -u "$CI_REGISTRY_USER" $CI_REGISTRY --password-stdin # Connection au registry gitlab
  script:
    - echo "Yé boiiiiii"
    - docker build -t $CI_REGISTRY/nevii/terraform_eks/app_temoin:v0.1 ./app
    - docker push $CI_REGISTRY/nevii/terraform_eks/app_temoin:v0.1
  artifacts:
    paths:
      - .docker/config.json
  tags:
    - build_job_docker
  when: manual

prepare_secret:
  stage: prepare
  image: alpine
  script:
    - cat .docker/config.json | base64 -w0 > config.b64
  artifacts:
    paths:
      - config.b64
  tags:
    - build_job_docker
  needs:
    - job: build-docker-image
      artifacts: true
  when: manual

validate:
  stage: validate
  image:
    name: hashicorp/terraform:latest
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  before_script:
    # - export AWS_ACCESS_KEY=${AWS_ACCESS_KEY_ID}
    # - export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
    - rm -rf .terraform
    - terraform --version
    - terraform init
  script:
    - terraform fmt -recursive
    - terraform validate
  # artifacts:
  #   paths:
  #     - aws.cfg
  when: manual
        # on_success
  tags:
    - build_job_docker
  

# plan:
#   stage: plan
#   image:
#     name: hashicorp/terraform:latest
#     entrypoint:
#       - '/usr/bin/env'
#       - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
#   before_script:
#     - export AWS_ACCESS_KEY=${AWS_ACCESS_KEY_ID}
#     - export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
#     - rm -rf .terraform
#     - terraform --version
#     - terraform init
#   script:
#     - terraform plan
#   dependencies:
#     - validate

apply:
  stage: apply
  image:
    name: hashicorp/terraform:latest
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  before_script:
    # - export AWS_ACCESS_KEY=${AWS_ACCESS_KEY_ID}
    # - export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
    - rm -rf .terraform
    - terraform --version
    - terraform init
  script:
    - terraform apply --auto-approve
    - EKS_CLUSTER_NAME=$(terraform output -raw cluster_name)
    - AWS_REGION=$(terraform output -raw region)
    - echo "EKS_CLUSTER_NAME=$EKS_CLUSTER_NAME" > vars.env # .env needs key value format, no empty lines nor comments
    - echo "AWS_REGION=$AWS_REGION" >> vars.env

  dependencies:
    # - plan
    - validate
    - build-docker-image
  when: manual
  tags:
    - build_job_docker
  artifacts:
    reports:
      dotenv: vars.env # export variables

deploy:
  stage: deploy
  image:
    name: amazon/aws-cli
    entrypoint: [""]
  environment:
    name: production
  before_script:
    - whoami
    - ls
    - curl -L https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 -o jq
    - chmod +x jq
    - mv jq /usr/local/bin/
    - yum update -y
    - yum install -y openssl git tar gzip build-essential # needed for Helm chart verification
  script:
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x ./kubectl
    - mv ./kubectl /usr/local/bin/kubectl
    - echo $EKS_CLUSTER_NAME
    - echo $AWS_REGION
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_REGION
    - aws eks update-kubeconfig --name $EKS_CLUSTER_NAME
    # - gitlab_config=$(cat $CI_PROJECT_DIR/.docker/config.json | jq -c '.auths["'$CI_REGISTRY'"]')
    # - base64_config=$(cat config.b64)
    # - echo $base64_config | base64 --decode > decoded_config.json
    # - kubectl create secret generic gitlab-cred --from-file=.dockerconfigjson=decoded_config.json=.dockerconfigjson=$decoded_config.json --type=kubernetes.io/dockerconfigjson
    - curl -L https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 -o /tmp/get_helm.sh
    - chmod 0700 /tmp/get_helm.sh
    - /tmp/get_helm.sh # Install Helm
    - curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.7.2/docs/install/iam_policy.json
    # Uncomment if infra destroyed
    # - aws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam_policy.json
    - kubectl create -f serviceaccount.yml --dry-run=client -o yaml | kubectl apply -f - # Apply the file if the resource does not exist
    - helm repo add eks https://aws.github.io/eks-charts
    - helm repo update eks
    - helm install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=$EKS_CLUSTER_NAME --set serviceAccount.create=false --set serviceAccount.name=aws-load-balancer-controller
    - kubectl create -f secret.yml --dry-run=client -o yaml | kubectl apply -f 
    - kubectl get deployment -n kube-system aws-load-balancer-controller
    - kubectl create -f deployment.yml --dry-run=client -o yaml | kubectl apply -f -
    - kubectl create -f service.yml --dry-run=client -o yaml | kubectl apply -f -
  needs:
    - job: prepare_secret
      artifacts: true
    - job: apply
      artifacts: true
  tags:
    - build_job_docker
  when: manual

monitoring:
  stage: monitor
  image: amazon/aws-cli
  before_script: 
    - yum update -y
    - yum install -y openssl git tar gzip build-essential
  script:
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x ./kubectl
    - mv ./kubectl /usr/local/bin/kubectl
    - echo $EKS_CLUSTER_NAME
    - echo $AWS_REGION
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_REGION
    - aws eks update-kubeconfig --name $EKS_CLUSTER_NAME
    - curl -L https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 -o /tmp/get_helm.sh
    - chmod 0700 /tmp/get_helm.sh
    - /tmp/get_helm.sh
    - helm repo add eks https://aws.github.io/eks-charts
    - helm repo update eks
    - helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    - helm repo update
    - | 
        cat <<EOF > values.yaml
        global:
          imagePullPolicy: IfNotPresent

        prometheus:
          prometheusSpec:
            replicas: 1
            serviceMonitorSelectorNilUsesHelmValues: false
            ruleSelectorNilUsesHelmValues: false
            podMonitorSelectorNilUsesHelmValues: false
            probeSelectorNilUsesHelmValues: false
            externalLabels:
              cluster: $EKS_CLUSTER_NAME
            securityContext:
              fsGroup: 2000
              runAsNonRoot: true
              runAsUser: 65534
            storageSpec:
              volumeClaimTemplate:
                spec:
                  accessModes: [ReadWriteOnce]
                  resources:
                    requests:
                      storage: 10Gi
            service:
              annotations:
                service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
                service.beta.kubernetes.io/aws-load-balancer-ssl-ports: https
              type: LoadBalancer

        alertmanager:
          alertmanagerSpec:
            replicas: 1
            externalLabels:
              cluster: $EKS_CLUSTER_NAME
            securityContext:
              fsGroup: 2000
              runAsNonRoot: true
              runAsUser: 65534
            service:
              annotations:
                service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
                service.beta.kubernetes.io/aws-load-balancer-ssl-ports: https
              type: LoadBalancer

        grafana:
          grafana:
            adminPassword: @Azurev69007
            service:
              annotations:
                service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
                service.beta.kubernetes.io/aws-load-balancer-ssl-ports: https
              type: LoadBalancer
      EOF
    - helm install kube-prometheus-stack prometheus-community/kube-prometheus-stack -f values.yaml
  tags:
    - build_job_docker
  when: manual


destroy:
  stage: destroy
  image:
    name: hashicorp/terraform:latest
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  before_script:
    - rm -rf .terraform
    - terraform --version
    - terraform init
  script:
    - terraform destroy --auto-approve
  # needs:
  #   - apply
  when: manual
  tags:
    - build_job_docker